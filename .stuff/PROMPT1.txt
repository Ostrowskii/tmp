nós acabamos de implementar o StateMachine.ts, um módulo que permite criar
jogose apps online definindo apenas um estado inicial, uma função de passagem de
tempo (on_tick) e uma função handler de posts (comandos, eventos) enviados pelos
jogadores (on_post). o StateMachine, junto ao server.ts e client.ts (um sistema
de "salas" online que permite postar e acompanhar mensagens postadas em uma sala
cujo id é um identificador de 48 bits, printado usando 6 bits por letra) se
responsabiliza por computar o estado do jogo a qualquer tempo, de modo que todos
os clients usando a mesma configuração do StateMachine vão ver o mesmo estado e,
portanto, renderizar o mesmo jogo.

o nosso objetivo agora é criar um mini jogo de terminal para servir como demo da
StateMachine.ts. esse jogo será bem simples: cada jogador é um "letra" que se
movimenta em um espaço 2D. para jogar, basta digitar o comando:

./letter <sala> <letra>

isso vai iniciar a StateMachine do jogo 'letter' na sala <sala>.

sm = SM(...)

o jogo letter tem, como estado inicial, um mapa 'char → player', sendo o player
definido por 6 campos: px, py, w, a, s, d, (posição e estado das teclas WASD),
e o char apenas um caractere qualquer.

a função on_tick simplesmente irá, para cada player no estado do jogo, incrementar
sua posição baseado no estado WASD:
player.px = player.px + (d * 1) + (a * -1)
player.py = player.py + (s * 1) + (w * -1)

a função on_post simplesmente irá atualizar o estado dos campos w, a, s, d de uma
determinada letra. exemplo:

{$:"down", key: "w", player: "X"}

isso realiza o comando 'w' em nome do player "X", fazendo:

player.w = 1

mesma coisa para up e para as outras letras.

importante: jamais faça mutação dos objetos dentro do estado do jogo.
sempre retorne um objeto novo de forma imutável.

o jogo vai rodar a 24 ticks por segundo.

o jogo vai ter uma tolerância de 100ms.

obs: ainda não implementamos a funcionalidade 'post' na StateMachine. devemos
extende-la com essa funcionalidade, simplesmente redirecionando para o post do
client.ts (wrapper). também não implementamos uma funcionalidade de computar o
estado atual. devemos criar o método compute_current_state, que chamará o
compute_state_at com o server_tick().

com esses campos, a StateMachine será capaz de automaticamente computar o estado
atual chamando sm.compute_current_state(). isso retornará um objeto do tipo do
estado do nosso jogo, a qualquer momento, com o estado atual dele.

essa aplicação deve incluir um render loop, que roda também a 24 frames por segundo.
esse loop irá dar clear na tela, e renderizar os players, da seguinte forma:

para cara player, pegamos a posição desse player, arrendondamos para baixo, e
colocamos a letra desse player na sua posição determinada na tela.

também precisamos incluir um post para iniciar em um player. exemplo:

{$:"spawn", nick: "X", px: 123, py: 500}

essa mensagem irá colocar o player no estado do jogo (de forma imutável).

se recebemos uma mensagem de um player inexistente, ignoramos.

não há sistema de autenticação (qualquer player pode mandar mensagem em nome de
qualquer outro player ativo).

existe algo que eu esqueci de especificar, que você precisa saber para
implementar o jogo?









