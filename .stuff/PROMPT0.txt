essa funcionalidade será implementada em um arquivo chamado StateMachine.ts (abreviado: SM).

esse arquivo irá importar o client.ts.

ele incluirá uma classe principal chamada StateMachine, cujo construtor receberá:

room : string ::= o nome (48-bit) da sala onde estarão os posts processados por essa StateMachine

init : S ::= o estado inicial do jogo/app computado por essa StateMachine

on_tick : S -> S ::= uma função de estado para estado que ocorre a todo 'tick' do app/jogo

on_post : P -> S -> S ::= uma função que recebe um post do jogador/user (P) e o
estado atual (S), e computa o próximo estado

tps : number ::= o número de ticks por segundo dessa aplicação
esses argumentos serão armazenados na classe. além disso, também armazenaremos:

.room_posts : Map<number,P> ::= um mapa de indice para post, incluindo todos os
posts existentes na sala selecionada (inicializado como uma mapa vazio)

no momento que a classe é instancializada (i.e., dentro do próprio construtor),
a gente vai chamar a função de watch do client.ts para acompanhar a sala
especificada. nessa mesma chamada, registraremos um callback que, todo vez que
um post for feito nessa sala, iremos adicionar esse post ao campo local
'.room_posts'. além disso, a gente também vai chamar a função load do client.ts
para carregar todos os eventos que acontecerem nessa sala, a partir do evento 0.
isso irá popular o .room_posts com todos os posts feitos na sala até então. para
escrever um post no room_posts, sempre faça pelo indice informado pelo servidor
(ex: self.room_posts[index] = post).

a classe StateMachine vai ter os seguintes metodos:

server_time() -> number: apenas retorna o server_time (re-exportado do client.ts)

initial_time() -> number | null: retorna o tempo de inauguração da sala, que é
determinado pelo server_time do primeiro post no on_post. se não houverem posts,
retorna nulo.

compute_state_at(server_time: number) -> S: computa o estado de um jogo/app em
um determinado server_time.

o compute_state_at funciona através do seguinte algoritmo:

primeiro, pegamos o initial_time da nossa sala. se for nulo, retornamos o estado
inicial (.init).

room : string ::= o nome (48-bit) da sala onde estarão os posts processados por essa StateMachine
init : S ::= o estado inicial do jogo/app computado por essa StateMachine
on_tick : S -> S ::= uma função de estado para estado que ocorre a todo 'tick' do app/jogo
on_post : P -> S -> S ::= uma função que recebe um post do jogador/user (P) e o estado atual (S), e computa o próximo estado
tps : number ::= o número de ticks por segundo dessa aplicação esses argumentos serão armazenados na classe.
tolerance : number ::= o quão no passado (em ms) iremos tolerar um post cujo client_time seja inferior ao server_time

além disso, também armazenaremos:
.room_posts : Map<number,P> ::= um mapa de indice para post, incluindo todos os posts existentes na sala selecionada (inicializado como uma mapa vazio)

no momento que a classe é instancializada (i.e., dentro do próprio construtor),
a gente vai chamar a função de watch do client.ts para acompanhar a sala
especificada. nessa mesma chamada, registraremos um callback que, todo vez que
um post for feito nessa sala, iremos adicionar esse post ao campo local
'.room_posts'. além disso, a gente também vai chamar a função load do client.ts
para carregar todos os eventos que acontecerem nessa sala, a partir do evento 0.
isso irá popular o .room_posts com todos os posts feitos na sala até então. para
escrever um post no room_posts, sempre faça pelo indice informado pelo servidor
(ex: self.room_posts[index] = post).

a classe StateMachine vai ter os seguintes metodos:

time_to_tick(server_time: number) -> number: converte o tempo global em um tick,
determinado por floor(server_time/tps)

server_time() -> number: apenas retorna o server_time (re-exportado do client.ts)
server_tick() -> number: retorna o tick do server (usa o time_to_tick para converter)

initial_time() -> number | null: retorna o tempo de inauguração da sala, que é
determinado pelo server_time do primeiro post no on_post. se não houverem posts,
retorna nulo.
initial_tick() -> number | null: retorna o tick de inauguração

compute_state_at(at_tick: number) -> S: computa o estado de um jogo/app em
um determinado tick.

o compute_state_at funciona através do seguinte algoritmo:

primeiro, pegamos o initial_tick da nossa sala. se for nulo, retornamos o estado inicial (.init).

segundo, se o at_tick for menor do que o initial_tick, retornamos o estado inicial (.init).

caso contrário, vamos, então, computar o estado desse app/jogo no tick solicitado.

para isso, inicializaremos um mapa de tick para array de posts chamado 'timeline'.

para cada post na sala (.room_posts):

a gente vai computar o "tempo oficial" (official_time) do post. computado o
tempo oficial, a gente vai computar também o tick oficial do post
(official_tick). na sequência, a gente vai adicionar esse post no mapa
'timeline', usando o official_tick como chave. após essa adição, a gente vai
ordenar esse array de posts desse tick usando o post.index como diferenciador.
isso garante que, caso haja um empate (mais de um post no mesmo tick), eles
serão ordenados da mesma forma por todos os computadores, pois usaremos o índice
determinado pelo servidor como critério de desempate.

nesse momento, teremos um mapa:

timeline : Map Tick [Post]

agora, computaremos, de fato, o estado do jogo no tempo solicitado.

para isso, criatemos uma variável chamada 'state : S', e inicializaremos ela com
self.init (ou seja, o estado inicial do jogo).

então, para cada tick, partindo do tick inicial, até o tick atual (solicitado):
- computaremos state = self.on_tick(state)
- para cada post no array de posts desse tick:
  - computaremos state = self.on_post(post, state)

enfim, retornaremos 'state', que é o estado do jogo no tick solicitado.

isso conclui o algoritmo compute_state_at.

computando o "tempo oficial" do post:

lembre-se que o post tem dois tempos: o server_time, que é o tempo no qual o
servidor recebeu esse post, e o client_time, que é o tempo que o client alegou
ter enviado esse post. em geral, queremos usar o client_time, pois isso dá uma
experiência mais fluida para cada jogador. porém, isso abre um vetor de ataque
onde um jogador pode enviar uma mensagem "no passado" para ganhar vantagens
durante uma partida. sendo assim, faremos a decisão de qual é o tempo oficial de
um post jogo a jogo, sendo que cada jogo especifica uma "tolerancia" de quanto
"no passado" um post será aceito (veja o campo tolerancy acima). usaremos esse
campo da seguinte forma: se o client_time for menor ou igual ao server_time
menos a tolerância, consideramos o tempo oficial como server_time menos a
tolerância. caso contrário, consideramos o tempo oficial como client_time.

obs:

atualmente o client.ts não expõe uma api com funções que outra lib pode chamar
(ex: client.watch, client.post, etc.) - ele é feito para ser usado apenas como
um app de linha de comando. para melhorar isso, antes de fazer a tarefa acima,
divida o client.ts em dois: client.ts, que será uma lib pura expondo esses
métodos, e client_cli.ts que é essa interface de linha de comando que nos
permite debugar o sistema. o client_cli.ts irá importar o client.ts. o
statemachine.ts irá importar o client.ts. o statemachine.ts não irá importar
o client_cli.ts.
